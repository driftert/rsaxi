use geo::Point;

/// Трей, що розширює функціонал `Point<f64>`.
/// Він надає додаткові методи для виконання поширених операцій, таких як
/// обчислення довжини (модуля), відстані, нормалізації та лінійної інтерполяції (lerp) між точками.
pub trait PointExtension {
    /// Обчислює довжину (модуль) вектора, що представлений точкою.
    /// Це еквівалентно евклідовій відстані від початку координат (0,0) до точки.
    fn length(&self) -> f64;

    /// Обчислює евклідову відстань між двома точками.
    ///
    /// # Параметри
    /// - `point`: Інша точка, до якої потрібно обчислити відстань.
    fn distance(&self, point: &Point<f64>) -> f64;

    /// Множить координати точки на скалярне значення.
    ///
    /// # Параметри
    /// - `b`: Скаляр, на який множаться координати точки.
    ///
    /// # Повертає
    /// Нову точку, координати якої пропорційні початковим координатам,
    /// але збільшені або зменшені на скалярний множник.
    fn mul_scalar(&self, b: f64) -> Point<f64>;

    /// Нормалізує точку (вектор), приводячи її до одиничної довжини.
    ///
    /// # Повертає
    /// Нову точку з одиничною довжиною, яка зберігає напрямок початкової точки.
    fn normalize(&self) -> Point<f64>;

    /// Виконує лінійну інтерполяцію (lerp) між двома точками на основі параметра `s`.
    ///
    /// # Параметри
    /// - `other`: Друга точка для інтерполяції.
    /// - `s`: Коефіцієнт інтерполяції (значення від 0 до 1).
    fn lerps(&self, other: &Point<f64>, s: f64) -> Point<f64>;
}

impl PointExtension for Point<f64> {
    fn length(&self) -> f64 {
        f64::hypot(self.x(), self.y())
    }

    fn distance(&self, other: &Point<f64>) -> f64 {
        f64::hypot(self.x() - other.x(), self.y() - other.y())
    }

    fn mul_scalar(&self, b: f64) -> Point<f64> {
        Point::new(self.x() * b, self.y() * b)
    }

    fn normalize(&self) -> Point<f64> {
        let d = self.length();
        if d == 0.0 {
            return Point::new(0.0, 0.0);
        }
        self.mul_scalar(1.0 / d)
    }

    fn lerps(&self, other: &Point<f64>, s: f64) -> Point<f64> {
        let v = (*other - *self).normalize();
        *self + v.mul_scalar(s)
    }
}
